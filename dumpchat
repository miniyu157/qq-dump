#!/system/bin/sh

# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2025 Yumeka <miniyu157@163.com>

# shellcheck shell=ksh

(($(id -u) != 0)) && exec su -c "$(printf "%q " "$(readlink -f "$0")" "$@")"
ScriptDir=$(dirname "$0")
export LD_LIBRARY_PATH="/data/data/com.termux/files/usr/lib"
export PATH="/data/data/com.termux/files/usr/bin:$PATH"

PYTHON_DIR="$ScriptDir/chat_export"
REQ_FILE="$PYTHON_DIR/requirements.txt"
PYTHON_EXEC="python"
for venv in "$PYTHON_DIR/.venv" "$PYTHON_DIR/venv"; do
    [[ -x "$venv/bin/python" ]] && {
        PYTHON_EXEC="$venv/bin/python"
        break
    }
done

command -v "$PYTHON_EXEC" > /dev/null 2>&1 || {
    printf "找不到 python, 在 Termux 中使用 'pkg install -y python' 以安装。" >&2
    exit 1
}

if [[ ! -f $REQ_FILE ]]; then
    printf "找不到文件 '%s'\n" "$REQ_FILE" >&2
    exit 1
fi

if ! "$PYTHON_EXEC" -m pip install -r "$REQ_FILE" > /dev/null 2>&1; then
    printf "补全 Python 依赖...\n"

    if [[ $PYTHON_EXEC == "python" ]]; then
        "$PYTHON_EXEC" -m venv "$PYTHON_DIR/.venv" || exit 1
        PYTHON_EXEC="$PYTHON_DIR/.venv/bin/python"

        "$PYTHON_EXEC" -m pip install -r "$REQ_FILE" || {
            printf "虚拟环境依赖安装失败。\n" >&2
            exit 1
        }
    else
        printf "安装失败, 建议检查 requirements.txt、网络或 pip 源。\n" >&2
        exit 1
    fi
fi

OUT_DIR=""
if [[ -d $1 ]]; then
    OUT_DIR="$1"
    shift
else
    printf "需要指定一个输出目录。" >&2
    exit 1
fi

[[ -f "$ScriptDir/lib/prog.sh" ]] || {
    echo "错误: 未找到 $ScriptDir/lib/prog.sh" >&2
    exit 1
}
source "$ScriptDir/lib/prog.sh"

STDOUT="$ScriptDir/dumpdb.out"
STDERR="$ScriptDir/dumpdb.err.out"
DB_OUT_DIR="/tmp/dumpchat.$$.tmp"
mkdir -p "$DB_OUT_DIR"

trap 'rm -f "$STDOUT" "$STDERR"; rm -rf "$DB_OUT_DIR"' EXIT HUP INT QUIT TERM

"$ScriptDir"/dumpdb --raw "$DB_OUT_DIR" > "$STDOUT" 2> "$STDERR" &
PID=$!
loading "$PID" Dumping...
wait "$PID" || {
    [[ -e $STDERR ]] && cat "$STDERR" >&2
    exit 1
}

# shellcheck disable=SC2046
set -- $(xargs < "$STDOUT")

if (($# == 0)) || [[ ! -d $1 ]]; then
    printf "未找到有效账号的转储数据。" >&2
    exit 1
fi

i=1
for file in "$@"; do
    printf "  [%d] %s\n" "$i" "${file##*/}"
    ((i++))
done

printf "选择一个账号: "
read -r choice < /dev/tty
if [[ -z $choice ]] || ((choice < 1 || choice > $#)); then
    exit 1
fi

shift $((choice - 1))
DB_DIR="$1"

printf "\n"

"$PYTHON_EXEC" "$PYTHON_DIR/main.py" --input "$DB_DIR" --output "$OUT_DIR"

# 此处不应使用 exec ...
# 确保内存盘中的文件能够正确清理
